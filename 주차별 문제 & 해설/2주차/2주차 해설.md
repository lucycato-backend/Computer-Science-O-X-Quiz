# 2주차 해설
## 네트워크
1. HTTPS 통신에서는 TLS가 SSL을 완전히 대체하였다. ( O )
- SSL(Secure Sockets Layer)은 원래 넷스케이프에 의해 개발되어 안전한 데이터 전송을 위해 웹 브라우저와 서버 사이의 암호화된 링크를 제공하는 데 사용되었다. SSL은 여러 버전을 거쳐 발전했으나, 보안 취약점이 발견되면서 더 안전한 대체 기술의 필요성이 되었다. TLS(Transport Layer Security)는 SSL의 후속 버전으로 개발되었으며, SSL 3.0의 직접적인 후계자로서 보안, 알고리즘, 프로토콜의 개선을 제공한다. TLS는 SSL 기반으로, 보다 강화된 보안 기능을 포함하고 있다. TSL가 SSL을 완전히 대체하였다고 말할 수 있는 이유는, 더이상 SSL을 지원하지 않는 브라우저가 대부분이기 때문이다.

2. SSL/TLS 암호화는 데이터를 전송하는 동안만 정보를 보호한다. ( O )
- SSL(Secure Sockets Layer) 및 TLS(Transport Layer Security)는 데이터가 인터넷을 통해 전송될 때 암호화하여 보호하는 프로토콜이다. 이 암호화는 데이터가 전송되는 동안에만 적용되며, 데이터가 최종 목적지에 도달한 후에는 데이터의 보호 여부가 해당 서버의 보안 정책에 의해 결정된다. 따라서, 전송 중인 데이터에 대한 보안을 강화하지만, 저장 중인 데이터에 대한 보호는 포함하지 않기 때문에 SSL/TLS 암호화는 데이터를 전송하는 동안만 정보를 보호한다고 할 수 있다.

## 데이터베이스

3. 정규화는 항상 데이터베이스 성능을 향상시킨다. ( X )
- 정규화는 데이터베이스 설계 시 데이터 중복을 최소화하고 데이터 일관성을 유지하는 데 도움이 되는 과정입니다. 정규화는 데이터 무결성을 강화하고 삽입, 삭제, 갱신 이상의 문제를 줄여줍니다. 하지만 정규화가 항상 데이터베이스 성능을 향상시키는 것은 아닙니다.

- 정규화의 단점 중 하나는 데이터가 여러 테이블로 분할되면서 복잡한 조인 연산이 많이 필요해질 수 있다는 것입니다. 이는 특히 대규모 데이터베이스에서 성능 저하를 초래할 수 있습니다. 예를 들어, 데이터 조회 시 여러 테이블을 조인해야 하므로 쿼리 성능이 떨어질 수 있습니다.

- 따라서, 정규화와 성능 간의 균형이 중요합니다. 데이터베이스 성능을 최적화하기 위해서는 정규화를 적절히 적용하되, 필요한 경우 비정규화를 통해 성능을 향상시킬 수 있습니다. 이는 특정 요구 사항과 사용 사례에 따라 달라질 수 있습니다.

4. 분산 데이터베이스는 여러 지역에 중복하여 분산 저장함으로서 가용성을 높일 수 있다는 특징이 있다. 또한 지역별 사이트들도 자치성(autonomy)을 가지고 독립적 동작이 가능하며 사용자들이 원하는 데이터가 어느 지역에 저장되어 있는지 알 수 있다는 특징이 있다. ( X )

- 사용자들은 원하는 데이터가 어느 지역에 저장되어 있는지를 신경쓰지 않고 데이터를 사용할 수 있다.
- 데이터베이스를 여러 지역에 중복하여 분산 저장하면 가용성 (availability)이 높아진다.
- 지역 사이트들도 어느 정도 자치성(autonomy)을 가지고 독립적으로 동작할 수 있다.
- 수평적 단편화(horizontal fragmentation)는 릴레이션 투플들을 몇 개의 부분집합(단편)으로 분할한 후, 각 부분집합을 서로 다른 사이트에 저장하는 것이다.

## 운영체제
5. 최단작업 우선 스케줄링 알고리즘(Shortest-Job First: SJF)은 비선점형 방식과 선점형 방식 두 가지로 구현될 수 있다. ( O )
- 최단작업 우선 스케줄링 알고리즘(Shortest-Job First, SJF)은 두 가지 방식으로 구현될 수 있습니다: 비선점형(Non-Preemptive)과 선점형(Preemptive) 방식입니다.

    - 비선점형 SJF: 한 번 CPU를 할당받은 프로세스는 자신의 작업이 끝날 때까지 CPU를 점유합니다. 다른 프로세스가 도착하더라도 현재 실행 중인 프로세스를 중단시키지 않습니다. 이는 간단하지만, 긴 작업이 짧은 작업 때문에 계속 밀리면 기아(Starvation) 문제가 발생할 수 있습니다.

    - 선점형 SJF: 선점형 방식의 SJF는 흔히 "Shortest Remaining Time First (SRTF)"라고도 불립니다. 새로운 프로세스가 도착했을 때, 그 프로세스의 남은 실행 시간이 현재 실행 중인 프로세스의 남은 실행 시간보다 짧으면 CPU를 새 프로세스에게 할당합니다. 이를 통해 평균 대기 시간을 최소화할 수 있지만, 컨텍스트 스위칭 오버헤드가 증가할 수 있습니다.

- 이 두 가지 방식 모두 실행 시간이 가장 짧은 작업을 우선적으로 처리한다는 기본 원칙을 따르지만, 선점 여부에 따라 동작 방식이 다릅니다.

6. 라운드 로빈(Round Robin) 스케줄링에서는 각 프로세스가 동일한 시간 할당량(타임 슬라이스)을 받으며, 이는 공정한 CPU 할당을 보장한다. ( O )
- 라운드 로빈(Round Robin) 스케줄링은 타임 슬라이스(time slice) 또는 타임 퀀텀(time quantum)이라고 불리는 고정된 시간 동안 각 프로세스에게 CPU를 할당하는 방식입니다. 각 프로세스는 순서대로 동일한 시간 할당량을 받으며, 시간 할당량이 끝나면 다음 프로세스로 전환됩니다. 이 방식은 공정한 CPU 할당을 보장하며, 모든 프로세스가 일정한 시간 내에 CPU를 사용할 수 있게 합니다. 그러나 타임 슬라이스가 너무 짧으면 컨텍스트 스위칭 오버헤드가 증가할 수 있고, 너무 길면 응답 시간이 길어질 수 있습니다.


## 자료구조
7. 이진탐색 트리(BST)의 평균 시간 복잡도는 O(n)이며 최악의 시간 복잡도는 O(logn)이다. ( X )
- 이진 탐색 트리(Binary Search Tree, BST)의 평균 시간 복잡도는 O(log n)이며, 최악의 시간 복잡도는 O(n)입니다.

- 평균 시간 복잡도 O(log n): 트리가 균형 있게 분포되어 있을 때, 탐색, 삽입, 삭제 연산의 시간 복잡도는 트리의 높이에 비례합니다. 균형 잡힌 트리에서는 높이가 log n에 비례하므로, 평균적으로 O(log n)의 시간 복잡도를 가집니다.

- 최악의 시간 복잡도 O(n): 트리가 편향되었을 때, 예를 들어 모든 노드가 한쪽으로만 치우친 경우, 트리의 높이는 최대 n이 될 수 있습니다. 이 경우 탐색, 삽입, 삭제 연산의 시간 복잡도는 O(n)이 됩니다.


8. 레드 블랙트리는 자가 균형 이진 탐색 트리이다. ( O )
- 평균적으로 이진 탐색 트리(Binary Search Tree, BST)의 탐색 시간 복잡도는 O(log n)입니다. 그러나 트리가 편향되면, 최악의 경우 탐색 시간 복잡도는 O(n)으로 증가할 수 있습니다. 이 문제를 해결하기 위해 균형 이진 탐색 트리(balanced binary search tree)를 사용합니다.

- 균형 트리는 모든 서브트리의 높이 차이가 최대 1 이하인 트리입니다. 이를 유지하기 위해 균형 인수(balance factor)를 사용합니다. 균형 인수는 왼쪽과 오른쪽 서브트리의 높이 차이를 의미합니다.

- 자기 균형 이진 탐색 트리(self-balancing binary search tree)는 균형 인수를 기반으로 삽입 및 삭제 후 트리의 균형을 자동으로 유지합니다. 이를 위해 다음과 같은 방법을 사용합니다:
    - 회전(Rotation): 트리의 구조를 변경하여 균형을 맞춥니다. 단순 회전(좌회전, 우회전)과 이중 회전(좌우 회전, 우좌 회전)이 있습니다.
- 대표적인 자기 균형 이진 탐색 트리에는 다음이 포함됩니다:
    - AVL 트리: 각 노드의 서브트리 높이 차이가 1을 넘지 않도록 유지합니다.
    - 레드 블랙 트리: 노드를 빨강 또는 검정으로 색칠하고 특정 규칙을 통해 균형을 유지합니다.
이러한 트리들은 높이를 O(log n)으로 유지하여, 탐색, 삽입, 삭제 연산이 모두 O(log n)의 시간 복잡도를 갖도록 합니다. 이를 통해 최악의 경우에도 효율적인 성능을 보장합니다.