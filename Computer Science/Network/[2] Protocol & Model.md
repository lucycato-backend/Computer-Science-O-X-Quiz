### 프로토콜과 모델

1. TCP 연결 설정에는 3-way handshake 과정이 필요하다. (O / X)
2. HTTPS 통신에서는 TLS가 SSL을 완전히 대체하였다. (O / X)
3. SSL/TLS 암호화는 데이터를 전송하는 동안만 정보를 보호한다. (O / X)
4. DNS 쿼리는 기본적으로 UDP 프로토콜을 사용한다. (O / X)
5. IP 주소의 클래스 B는 127.0.0.0부터 시작한다. (O / X)
6. TCP/IP 모델에서 응용 계층은 직접 하드웨어와 통신한다. (O / X)

## 해설

### 1. TCP 연결 설정에는 3-way handshake 과정이 필요하다. O
TCP는 신뢰성 있는 데이터 전송을 위해 연결 지향적 프로토콜을 사용한다. 연결을 시작하기 전에, TCP는 3-way handshake 과정을 수행한다. 
#### 3 way-handshake(세션 연결)
  <img src="https://blog.kakaocdn.net/dn/colneJ/btrEE0Ggbwx/VzhD9eByIMPCRSn6QSGGy1/img.png" height=500/>

이 과정에서 클라이언트와 서버는 SYN(Synchronize), SYN-ACK(Synchronize-Acknowledge), ACK(Acknowledge) 패킷을 순차적으로 주고받으며, 이를 통해 양방향 통신이 가능한 안정적인 연결을 설정한다.

**Step1. [Client -> SYN -> Server]**
Client가 Server에게 접속을 요청하는 SYN플래그를 보낸다.

**Step2. [Server -> SYN + ACK -> Client]**
Server는 Listen상태에서 SYN이 들어온 것을 확인하고 SYN_RECV상태로 바뀌어 SYN + ACK플래그를 Client에게 전송한다. 그 후 Server는 다시 ACK 플래그를 받기 위해 대기상태로 변경된다.

**Step3. [Client -> ACK -> Server]****
SYN + ACK 상태를 확인한 Client는 서버에게 ACK를 보내고 연결 성립(Established)이 된다. 
#### 4 way-handshake(세션 종료)
<img src="https://blog.kakaocdn.net/dn/t6DvO/btrEDRCPzv1/OZkk7v80ZeXxftjCrOE710/img.png" height=500/>

**Step1. [Client -> FIN -> Server]**
Client가 연결을 종료하겠다는 FIN플래그를 전송한다. 보낸 후에 FIN-WAIT-1 상태로 변한다.

**Step2. [Server-> ACK -> Client]**
FIN 플래그를 받은 Server는 확인메세지인 ACK를 Client에게 보내준다. 그 후 CLOSE-WAIT상태로 변한다. Client도 마찬가지로 Server에서 종료될 준비가 됐다는 FIN을 받기위해  FIN-WAIT-2 상태가 된다.

**Step3. [**Server** -> FIN -> **Client**]**
Close준비가 다 된 후 Server는 Client에게 FIN 플래그를 전송한다.

**Step4. [Client -> ACK-> Server]**
Client는 해지 준비가 되었다는 정상응답인 ACK를 Server에게 보내준다. 이 때, Client는 TIME-WAIT 상태로 변경된다.

여기서 **TIME-WAIT 상태는 의도치않은 에러로 인해 연결이 데드락으로 빠지는 것을 방지**하기 위해 변경 되는 것인데, 만약 에러로 인해 종료가 지연되다가 타임이 초과되면 CLOSED 상태로 변경된다.

출처: [https://jeongkyun-it.tistory.com/180](https://jeongkyun-it.tistory.com/180) [나의 과거일지:티스토리]

### 2. HTTPS 통신에서는 TLS가 SSL을 완전히 대체하였다. O
SSL(Secure Sockets Layer)은 원래 넷스케이프에 의해 개발되어 안전한 데이터 전송을 위해 웹 브라우저와 서버 사이의 암호화된 링크를 제공하는 데 사용되었다. SSL은 여러 버전을 거쳐 발전했으나, 보안 취약점이 발견되면서 더 안전한 대체 기술의 필요성이 되었다.
TLS(Transport Layer Security)는 SSL의 후속 버전으로 개발되었으며, SSL 3.0의 직접적인 후계자로서 보안, 알고리즘, 프로토콜의 개선을 제공한다. TLS는 SSL 기반으로, 보다 강화된 보안 기능을 포함하고 있다.
TSL가 SSL을 완전히 대체하였다고 말할 수 있는 이유는, 더이상 SSL을 지원하지 않는 브라우저가 대부분이기 때문이다.

[현재 브라우저 호환 가능 SSL/TLS 버전 확인](https://clienttest.ssllabs.com:8443/ssltest/viewMyClient.html)

위 링크에서 확인해보면, SSL 인증 버전은 호환되지 않음을 알 수 있고, 우리가 HTTPS 통신을 위해 사용하는 SSL 인증서라는 명칭도 사실은 TSL 인증서라고 불러야하지만, 관습처럼 남아있는 단어이다.

### 3. SSL/TLS 암호화는 데이터를 전송하는 동안만 정보를 보호한다. O
SSL(Secure Sockets Layer) 및 TLS(Transport Layer Security)는 데이터가 인터넷을 통해 전송될 때 암호화하여 보호하는 프로토콜이다. 이 암호화는 데이터가 전송되는 동안에만 적용되며, 데이터가 최종 목적지에 도달한 후에는 데이터의 보호 여부가 해당 서버의 보안 정책에 의해 결정된다. 따라서, 전송 중인 데이터에 대한 보안을 강화하지만, 저장 중인 데이터에 대한 보호는 포함하지 않기 때문에 SSL/TLS 암호화는 데이터를 전송하는 동안만 정보를 보호한다고 할 수 있다.


### 4. DNS 쿼리는 기본적으로 UDP 프로토콜을 사용한다. O
DNS 쿼리는 대부분 UDP 프로토콜을 사용하여 진행된다. UDP를 사용하는 이유는 DNS 요청과 응답이 대체로 짧고, 빠른 속도가 요구되기 때문이다. 비연결 지향적인 UDP는 이러한 특성 때문에 DNS 쿼리에 적합하다. 단, 요청이나 응답의 크기가 큰 경우나 추가적인 신뢰성이 필요한 상황에서는 TCP를 사용할 수도 있다.

#### DNS 쿼리란?
DNS(Domain Name System)는 인터넷의 전화번호부와 같은 역할을 한다. 사람들이 웹사이트 주소(도메인 이름)를 브라우저에 입력할 때, DNS 서버는 해당 도메인 이름을 IP 주소로 변환하여 컴퓨터가 해당 서버와 통신할 수 있도록 돕는다. 이 과정에서 발생하는 도메인 이름의 요청과 IP 주소의 응답이 바로 DNS 쿼리이다.

#### 왜 DNS 쿼리에 UDP 프로토콜을 사용하는가?
DNS 쿼리는 기본적으로 UDP(User Datagram Protocol) 프로토콜을 사용하는데, 그 이유는 다음과 같다:
1. 속도: UDP는 연결 설정 과정이 필요 없는 비연결성 프로토콜이다. TCP와 달리 핸드셰이크나 연결 상태를 유지할 필요가 없어 데이터를 더 빠르게 전송할 수 있. DNS 쿼리와 같은 간단하고 짧은 요청에는 빠른 응답이 중요하다.

2. 간결함: UDP는 헤더가 간단하고 오버헤드가 적다. DNS 요청과 응답은 일반적으로 작은 데이터 패킷으로 구성되어 있으며, 이를 처리하기에 UDP는 효율적이다.

3. 자원 효율성: 대규모 DNS 서버는 많은 수의 요청을 동시에 처리해야 한다. UDP를 사용하면 연결을 유지하고 관리하는 데 드는 자원을 줄일 수 있다.

4. 편의성: 대부분의 DNS 응답은 하나의 UDP 패킷으로 처리할 수 있다. 이는 단일 요청과 응답에서 복잡한 흐름 제어나 오류 처리가 필요하지 않다는 것을 의미한다.

그러나, UDP는 패킷의 손실이나 순서 문제를 자체적으로 해결하지 못하므로, DNS 쿼리가 너무 크거나 신뢰성이 중요한 경우 TCP를 사용하기도 한다. 예를 들어, DNS 응답이 UDP 패킷 크기를 초과하는 경우나 DNSSEC(DNS Security Extensions)과 같이 보안이 강화된 쿼리에서는 TCP가 사용될 수 있다. 하지만 문제는 "DNS 쿼리에 *기본적으로* UDP 프로토콜을 사용한다"이므로, O이다.


### 5. IP 주소의 클래스 B는 127.0.0.0부터 시작한다. X
IP 주소의 클래스 시스템은 A, B, C, D, E 클래스로 구분된다. 클래스 A의 주소 범위는 1.0.0.0부터 126.0.0.0까지이며, 클래스 B의 주소 범위는 128.0.0.0부터 191.255.0.0까지이다. 127.0.0.0은 루프백 주소로 사용되며, 클래스 B에 속하지 않는다.

#### IP 주소 클래스 범위 

|       | IP 범위                       | 사용처                                         |
| ----- | --------------------------- | ------------------------------------------- |
| 클래스 A | 1.0.0.0 ~ 126.255.255.255   | 주로 대규모 네트워크에 사용됩니다.                         |
| 클래스 B | 128.0.0.0 ~ 191.255.255.255 | 중형 네트워크에 적합합니다.                             |
| 클래스 C | 192.0.0.0 ~ 223.255.255.255 | 소규모 네트워크에 사용됩니다.                            |
| 클래스 D | 224.0.0.0 ~ 239.255.255.255 | 이 클래스는 멀티캐스트 그룹을 위해 예약되어 있습니다.              |
| 클래스 E | 240.0.0.0 ~ 255.255.255.255 | 실험적 목적으로 예약되어 있으며 일반적인 네트워크 용도로는 사용되지 않습니다. |

#### 127.0.0.0 루프백 주소
- 범위: 127.0.0.0 ~ 127.255.255.255
- 이 범위의 IP 주소는 네트워크 통신을 위해 외부로 전송되지 않고, 컴퓨터가 자체적으로 자신을 테스트하거나 시스템을 구성하는 데 사용된다.
- 가장 잘 알려진 루프백 주소는 127.0.0.1입니다. 이 주소는 ‘localhost’ 또는 ‘자신’을 가리키며, 네트워크 소프트웨어 개발이나 시스템의 네트워크 설정을 테스트할 때 사용된다.
- 127.0.0.0은 클래스 A에 속하지만, 일반적인 클래스 A 주소처럼 사용되지 않습니다. 이는 특별히 내부 루프백과 네트워크 테스트 용도로 예약되어 있기 때문이다.

### 6. TCP/IP 모델에서 응용 계층은 직접 하드웨어와 통신한다. X
  <img src="https://images.velog.io/images/jehjong/post/3baa39bd-9a39-48bd-89b1-2516004172dd/image.png" height=500/>
TCP/IP 모델에서 응용 계층은 네트워크 통신의 최상위 계층으로, 사용자와 직접 상호 작용하는 소프트웨어 애플리케이션을 포함한다. 계층은 직접 하드웨어와 통신하지 않으며, 대신 네트워크 서비스를 사용하여 통신을 수행한다. 하드웨어와의 직접적인 통신은 물리 계층과 데이터 링크 계층에서 이루어진다.