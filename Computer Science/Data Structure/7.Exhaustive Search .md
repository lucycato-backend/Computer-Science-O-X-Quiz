# Exhaustive Search
## 문제

* DFS는 스택또는 재귀로 구현가능하다.

* DFS는 최단경로를 찾는데 BFS보다 유리하다.

* BFS는 큐로 구현가능하다.

* BFS는 출발지와 도착지 경로로 찾은 값이 최단 경로라는 보장이 없다.

  




## 답
![](https://github.com/justindevcode/TIL/assets/108222981/2a354d0b-245a-4880-892a-f82bfb7139bf)

* DFS는 스택또는 재귀로 구현가능하다. o

* DFS는 최단경로를 찾는데 BFS보다 유리하다. x

* BFS는 큐로 구현가능하다. o

* BFS는 출발지와 도착지 경로로 찾은 값이 최단 경로라는 보장이 없다. x

## DFS
스택, 재귀로 구현  
깊이우선 탐색  
BFS 보다 간단, BFS 비해서 검색 속도 느림  

* 장점

BFS에 비해 저장공간의 필요성이 적다. 백트래킹을 해야하는 노드들만 저장해주면 된다.  
찾아야하는 노드가 깊은 단계에 있을 수록, 그 노드가 좌측에 있을 수록 BFS보다 유리하다.  

* 단점

답이 아닌 경로가 매우 깊다면, 그 경로에 깊이 빠질 우려가 있다.  
찾은 값이 최단 경로라는 보장이 없다.  

* DFS로 풀었을 때, 유리한 상황

이동할 때마다 가중치가 붙거나 이동 과정에서 여러 제약이 있을 경우 DFS로 접근하면 탐색 시간은 더 걸리지만, 가중치에 대한 변수를 지속해서 관리할 수 있다는 장점이 있어서 코드 구현에 더 편리하다.  
모든 노드를 방문해야할 때나 재귀적으로 계속 호출해야하는 문제일 경우예) 모든 경우의 수  
경로의 특징을 저장해둬야 하는 문제일 경우예) 각 정점에 숫자가 적혀있고 a부터 b까지 가는 경로를 구하는데 경로에 같은 숫자가 있으면 안 된다는 문제 등  

## BFS
큐로 구현  
너비우선탐색  
재귀적으로 동작하지않음  

* 장점

너비를 우선으로 탐색하기 때문에 답이 되는 경로가 여러 개인 경우에도 최단 경로임을 보장한다.  
최단 경로가 존재한다면, 어느 한 경로가 무한히 깊어진다 해도 최단 경로를 반드시 찾을 수 있다.  
노드 수가 적고 깊이가 얕은 값이 존재 할 때 유리하다.  

* 단점

재귀호출을 사용하는 DFS와 달리 큐를 이용해 다음에 탐색 할 노드들을 저장하는데, 노드의 수가 많을 수록 필요없는 노드들까지 저장해야 하기 때문에 더 큰 저장공간 필요하다.  
노드의 수가 늘어나면 탐색해야하는 노드가 많아지기 때문에 비효율적이다.  
 
* BFS로 풀었을 때, 유리한 상황

현재 나의 위치에서 가장 가까운 노드를 먼저 방문하는 알고리즘  
최단거리(최소 횟수)를 찾는 문제와 임의의 경로를 찾는 문제예) 미로 탐색 문제  
검색대상의 규모가 크지 않고, 검색 시작 지점으로부터 원하는 대상이 별로 멀지 않은 경우  

#### 출처
https://velog.io/@hyehyes/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%99%84%EC%A0%84%ED%83%90%EC%83%89  
https://annajin.tistory.com/141  
