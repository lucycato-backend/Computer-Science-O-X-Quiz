## 문제

* 선택정렬의 시간복잡도는 최선 평균 최악 모두 O(n^2)이다. O/X

* 삽입정렬은 최선의경우에는 O(n)의 시간복잡도를 가지게된다. O/X

* 버블정렬을 수행할때 공간복잡도는 O(n^2)이다. O/X

* 퀵정렬은 이미 정렬된 데이터에서 매우 효율적이다. O/X

* 병합정렬은 LikedList를 사용해서 구현하면 더 효율적이다. O/X

* 힙 정렬은 최악의 경우에는 시간복잡도가 O(n^2)이 나올 수 있다. O/X

---

## 답

* 선택정렬의 시간복잡도는 최선 평균 최악 모두 O(n^2)이다. O

선택정렬  
![](https://github.com/justindevcode/TIL/assets/108222981/488cb547-bf1f-4197-9f1a-fda0e438f3fd)  
`선택 정렬은 주어진 배열에서 가장 작은 값을 찾아 첫 번째 원소와 교환한 후, 그 다음으로 작은 값을 두 번째 원소와 교환하는 방식을 반복하여 정렬을 수행한다.`  
시간복잡도  
선택 정렬의 시간 복잡도는 O(n^2)이며 최선, 평균, 최악의 경우 모두 동일하다.  
모두 정렬된 배열이어도 배열의 길이만큼 배열의 처음부터 끝까지 순회해야 하기 때문이다.  

공간복잡도  
주어진 배열 안에서 교환(swap)을 통해, 정렬이 수행되므로 O(1)이다.  

---

* 삽입정렬은 최선의경우에는 O(n)의 시간복잡도를 가지게된다. O

삽입정렬  
![1](https://github.com/justindevcode/TIL/assets/108222981/7600f4a8-e931-4619-8c59-91c36678f5be)  
`삽입 정렬은 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고, 정렬되지 않은 부분의 첫 번째 원소를 정렬된 부분에 적절한 위치에 삽입하는 방식으로 정렬을 수행한다.`  
시간복잡도  
선택 정렬의 시간 복잡도는 O(n^2)이며 최악과 평균은 동일하다. 하지만, 모두 정렬이 되어 있는 경우, 한 번씩 밖에 비교를 안하므로 최선의 경우 O(n)의 시간 복잡도를 가지게 된다.  

공간복잡도  
주어진 배열 안에서 교환(swap)을 통해, 정렬이 수행되므로 O(1)이다.  

---

* 버블정렬을 수행할때 공간복잡도는 O(n^2)이다. O

버블정렬  
![1](https://github.com/justindevcode/TIL/assets/108222981/b9d0da74-900b-4809-870b-c60467a7d3b3)  
`버블 정렬은 인접한 두 원소를 비교하고 필요에 따라 위치를 교환하는 방식으로 정렬을 수행한다.`  
시간복잡도  
버블 정렬은 정렬이 돼있던 안돼있던, 2개의 원소를 비교하기 때문에 최선, 평균, 최악의 경우 모두 시간 복잡도가 O(n^2)으로 동일하다.  

공간복잡도  
주어진 배열 안에서 교환(swap)을 통해, 정렬이 수행되므로 O(1)이다.  

---

* 퀵정렬은 이미 정렬된 데이터에서 매우 효율적이다. X

퀵정렬  
![1](https://github.com/justindevcode/TIL/assets/108222981/970ed6a1-4c45-4a19-a15b-6f35e94df522)  
`퀵 정렬은 분할 정복 방식을 사용하여 배열을 피벗(pivot)을 기준으로 두 부분으로 나눈 후 각 부분을 재귀적으로 정렬한다.`  
시간복잡도  
퀵 정렬의 시간 복잡도는 O(n log n)이며 최선, 평균은 동일하고 최악의 경우 O(n^2)이다.  
삽입 정렬과는 반대로 퀵 정렬은 이미 정렬된 데이터라면 매우 비효율적으로 작용한다.  

공간복잡도  
퀵 정렬은 정렬을 위해 평균적으로 O(log n)만큼의 memory를 필요로한다. 이는 재귀적 호출로 발생하는 것이며, 최악의 경우 O(n)의 공간복잡도를 보인다.  

---

* 병합정렬은 LikedList를 사용해서 구현하면 더 효율적이다. O

병합정렬  
`병합 정렬은 분할 정복(Divide and Conquer) 방식을 사용하여 배열을 반으로 나눈 후 각 부분을 재귀적으로 정렬하고, 나중에 병합하여 정렬된 배열을 생성한다.`  
![1](https://github.com/justindevcode/TIL/assets/108222981/99f8bfc9-8cba-4d10-887a-407cc4b84ddf)  
시간복잡도  
병합 정렬의 시간 복잡도는 O(n log n)이며, 최선, 평균, 최악의 경우 모두 동일하다.  
데이터를 정확히 반으로 나누고 정렬하기 때문에 항상 일정한 시간 복잡도를 유지하므로 퀵 정렬의 한계점을 보완할 수 있는 장점  

공간복잡도  
LikedList를 사용시 O(1)  
그외 O(n)  
병합 정렬은 순차적인 비교로 정렬을 진행하므로, LinkedList 정렬이 필요할 때 사용하면 효율적이다.  
만약 배열을 linked list(연결 리스트)로 구현하면 인덱스만 변경되므로 데이터의 이동 및 복사를 하지 않아도 된다.  

```
@ 배열 혹은 리스트로 구현하는 경우

1. 쪼갠다(재귀적으로)
- 나눠지는 집합별에 대해 각각의 startIndex, endIndex를 찾는다.(실제 쪼개지는 것이 아님)

 

2. 정렬하면서 합친다.
- 두 집합을 비교하여 정렬된 상태로 임시 배열에 저장한 뒤, 원본 배열에 이를 다시 옮겨준다.
- 하나만 예시를 들면 위 그림에서 "크기가 8인 정렬"이라고 쓰여있는 부분에서 아래의 과정이 일어난다.
   [2, 10, 30, 69] [8, 16, 22, 31] 두 집합을 정렬된 상태로 임시 배열b에 [2, 8, 10, 16, 22, 30, 31, 69] 저장하고
   이를 다시 원본 배열a에 할당해줘야함. a[i] = b[i]
   이 과정은 2개의 집합이 1개의 집합으로 합쳐질 때 항상 이뤄지므로 오버헤드가 상당하다.

 

@ 연결 리스트로 구현하는 경우

1. 쪼갠다(재귀적으로)

- 각 단계에서 링크드 리스트를 2개의 링크드 리스트로 분리시켜준다.  
   head -> Node1 -> Node2 -> Node3 -> Node4 이면 
   head -> Node1 -> Node2, head2 -> Node3 -> Node4 으로.

2. 정렬하면서 합친다.
- 노드의 Next를 변경해주는 것을 통해 정렬하면서 합친다.
- 합치는 과정은 head가 2개였던 것을 1개로 합쳐주며 이뤄짐.
```

---

* 힙 정렬은 최악의 경우에는 시간복잡도가 O(n^2)이 나올 수 있다. X

힙 정렬  
![1](https://github.com/justindevcode/TIL/assets/108222981/caf91cef-6d98-48d4-b765-48ef57bdff28)  
`힙 정렬은 힙 자료구조를 사용하여 정렬을 수행하는 방식으로, 주어진 배열을 최대 힙 또는 최소 힙으로 구성한 후 힙에서 원소를 하나씩 꺼내 정렬한다.`  
시간복잡도  
힙 정렬의 시간 복잡도는 O(n log n)이며, 최선, 평균, 최악의 경우 모두 동일하다.  
완전 이진트리를 사용한다.  

공간복잡도  
O(1)  

---

![1](https://github.com/justindevcode/TIL/assets/108222981/624a08bc-7946-4d4a-9291-2bc15dd8e6a7)


## 참조
https://velog.io/@ajm0718/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%97%90-%EB%8C%80%ED%95%9C-%EB%B3%B5%EC%9E%A1%EB%8F%84  
